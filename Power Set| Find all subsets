The idea is: each subset can be represented by a binary number.
# Suppose nums = [1, 2, 3]
# Total subsets = 2^3 = 8
# Each bit in a binary number represents whether we take that element (1) or skip it (0).
# Binary | Subset
# -------|--------
# 000    | []
# 001    | [3]
# 010    | [2]
# 011    | [2,3]
# 100    | [1]
# 101    | [1,3]
# 110    | [1,2]
# 111    | [1,2,3]

# So we loop from 0 to (2^n - 1)
# and for each number, check which bits are set to decide what to include.

#include <bits/stdc++.h>
using namespace std;

#include <bits/stdc++.h>   // includes all standard libraries
using namespace std;

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();          // get number of elements in input array
        vector<vector<int>> ans;      // this will store all subsets

        int total = 1 << n;           // total subsets = 2^n  (bitwise left shift)

        // iterate over all possible binary masks from 0 to (2^n - 1)
        for (int mask = 0; mask < total; mask++) {
            vector<int> subset;       // store current subset elements

            // check every bit of the current mask
            for (int i = 0; i < n; i++) {
                // if i-th bit is set, include nums[i] in subset
                if (mask & (1 << i)) {
                    subset.push_back(nums[i]);
                }
            }

            ans.push_back(subset);    // add the subset to the final answer
        }

        return ans;                   // return all generated subsets
    }
};

# ðŸª„ Each subset â†” one binary number between 0 and 2^n - 1
# ðŸª„ If i-th bit is 1 â†’ include nums[i]
# ðŸª„ Loop all masks and collect subsets
#
# âœ… Time: O(n * 2^n)
# âœ… Space: O(n * 2^n)
# âœ… Fast, no recursion, clean logic

