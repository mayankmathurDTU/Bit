# ğŸ”¹ Decimal <-> Binary Conversion in C++

# ------------------ THEORY ------------------
# âœ… Decimal to Binary:
# In base-10 (decimal), each digit represents powers of 10.
# In base-2 (binary), each bit represents powers of 2.
# To convert decimal â†’ binary:
#   1. Divide the decimal number by 2 repeatedly.
#   2. Store the remainders (0 or 1).
#   3. Reverse the order of remainders â†’ gives binary.

# Example: Decimal 25
# 25 / 2 = 12 remainder 1
# 12 / 2 = 6  remainder 0
# 6  / 2 = 3  remainder 0
# 3  / 2 = 1  remainder 1
# 1  / 2 = 0  remainder 1
# Binary = reverse(10011) = 11001

# âœ… Binary to Decimal:
# Each binary digit is multiplied by 2 raised to its position (from right to left).
# Example: Binary 11001
# = (1Ã—2â´) + (1Ã—2Â³) + (0Ã—2Â²) + (0Ã—2Â¹) + (1Ã—2â°)
# = 16 + 8 + 0 + 0 + 1 = 25

# ------------------ PSEUDO CODE ------------------
# function decimalToBinary(decimal):
#     binary = ""
#     while decimal > 0:
#         remainder = decimal % 2
#         binary = remainder + binary
#         decimal = decimal // 2
#     return binary
#
# function binaryToDecimal(binaryString):
#     decimal = 0
#     power = 0
#     for i from last digit to first:
#         if binaryString[i] == '1':
#             decimal = decimal + 2^power
#         power = power + 1
#     return decimal

int -> 32 bits
long long -> 64 bits


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

# ğŸ”¹ 1's Complement and 2's Complement in C++

# ------------------ THEORY ------------------

# âœ… 1's Complement:
# â†’ It is formed by inverting (flipping) all bits of a binary number.
#   0 becomes 1, and 1 becomes 0.
# Example:
#   Binary:  1010
#   1's Comp:0101
#
# ğŸ‘‰ Meaning: 1â€™s complement represents the negative of a number in older systems.
# However, it has two representations for zero (+0 and -0), which is inefficient.
# So modern computers use 2â€™s complement.

# âœ… 2's Complement:
# â†’ It is formed by taking the 1â€™s complement and then adding 1 to it.
# Example:
#   Binary:  1010
#   1's Comp:0101
#   Add 1   :0110  â†’ This is 2â€™s complement.
#
# ğŸ‘‰ Meaning: 2â€™s complement represents signed numbers in most systems.
# The leftmost bit (MSB) acts as the sign bit:
#   0 â†’ Positive number
#   1 â†’ Negative number
#
# Example for 4-bit system:
#   +5 â†’ 0101
#   -5 â†’ 2â€™s complement of 0101 â†’ 1011

# ------------------ PSEUDO CODE ------------------

# function onesComplement(binaryString):
#     for each bit in binaryString:
#         if bit == '0': change to '1'
#         else: change to '0'
#     return new binaryString

# function twosComplement(binaryString):
#     ones = onesComplement(binaryString)
#     carry = 1
#     result = ""
#     for i from last bit to first:
#         if ones[i] == '1' and carry == 1:
#             result = '0' + result
#         elif ones[i] == '0' and carry == 1:
#             result = '1' + result
#             carry = 0
#         else:
#             result = ones[i] + result
#     return result

# ------------------ C++ CODE ------------------
string twosComplement(string bin) {
    string ones = onesComplement(bin);
    string result = ones;
    int carry = 1;
    for (int i = bin.size() - 1; i >= 0; i--) {
        if (ones[i] == '1' && carry == 1)
            result[i] = '0';
        else if (ones[i] == '0' && carry == 1) {
            result[i] = '1';
            carry = 0;
        } else
            result[i] = ones[i];
    }
    return result;
}
# ------------------ SUMMARY ------------------
# 1â€™s Complement â†’ Flip all bits
# 2â€™s Complement â†’ Flip all bits + Add 1
# They are used to represent and perform arithmetic on negative numbers in binary.

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

# ğŸ§  How Compiler Stores Positive and Negative Numbers (int32)
# ------------------------------------------------------------

# A 32-bit integer uses 32 bits (4 bytes) to represent numbers.
# The **most significant bit (MSB)** is the **sign bit**:
#   0 â†’ positive
#   1 â†’ negative

# Example: +5
# Binary (32-bit): 00000000 00000000 00000000 00000101
# Sign bit = 0 â†’ positive
# Stored as-is.

# Example: -5
# Step 1ï¸âƒ£: Write +5 in binary â†’ 00000000 00000000 00000000 00000101
# Step 2ï¸âƒ£: Take 1â€™s complement (invert bits)
#           â†’ 11111111 11111111 11111111 11111010
# Step 3ï¸âƒ£: Add 1 â†’ 11111111 11111111 11111111 11111011
# âœ… This is -5 in 2â€™s complement form.

# ğŸ‘‰ So compiler stores:
#    Positive numbers â†’ as normal binary
#    Negative numbers â†’ in 2â€™s complement format
#
# Range for int32:
#    -2,147,483,648 to +2,147,483,647

----------------------------------------------------------------------------------

# ğŸ§  How to Interpret: 11111111 11111111 11111111 11111011
# ---------------------------------------------------------

# Step 1ï¸âƒ£: Check the sign bit (MSB)
# 1 â†’ negative number
# So, this is a NEGATIVE number stored in 2â€™s complement form.

# Step 2ï¸âƒ£: Convert back to positive magnitude
# To find its actual value:
#   â¤ Invert all bits (1â€™s complement)
#   â¤ Add 1

# Binary: 11111111 11111111 11111111 11111011
# 1â€™s complement â†’ 00000000 00000000 00000000 00000100
# Add 1 â†’           00000000 00000000 00000000 00000101

# Step 3ï¸âƒ£: Convert to decimal
# 00000000 00000000 00000000 00000101 = 5

# Step 4ï¸âƒ£: Apply the sign
# Since sign bit = 1 â†’ itâ€™s negative

# âœ… Final Answer: -5

# Summary:
# 11111111 11111111 11111111 11111011 â†’ represents -5 in 32-bit signed integer (2â€™s complement)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


# ğŸ§  What Happens When We Take NOT (~) of 5 and -5
# -------------------------------------------------
# The NOT (~) operator flips every bit in the binary representation.

# Let's use 32-bit integers for clarity.

# -------------------------------------------------
# ğŸ”¹ Step 1: Represent +5 in binary (int32)
# 5 = 00000000 00000000 00000000 00000101

# -------------------------------------------------
# ğŸ”¹ Step 2: Apply bitwise NOT (~)
# ~5 = 11111111 11111111 11111111 11111010

# This looks like a negative number (MSB = 1)
# To find its value:
#   Take 1â€™s complement (invert bits) â†’ 00000000 00000000 00000000 00000101
#   Add 1 â†’ 00000000 00000000 00000000 00000110 = 6
# Apply negative sign â†’ -6

# âœ… So, ~5 = -6

# -------------------------------------------------
# ğŸ”¹ Step 3: Represent -5 in binary (2â€™s complement)
# +5 = 00000000 00000000 00000000 00000101
# Invert bits â†’ 11111111 11111111 11111111 11111010
# Add 1 â†’ 11111111 11111111 11111111 11111011  (this is -5)

# -------------------------------------------------
# ğŸ”¹ Step 4: Apply NOT
# ~(-5) = invert all bits
# ~(-5) = 00000000 00000000 00000000 00000100 = +4

# âœ… So, ~(-5) = 4

# -------------------------------------------------
# ğŸ”¹ Step 5: Summary
# ~5   = -6
# ~(-5) = 4

# âš™ï¸ Why?
# In 2â€™s complement:
#   ~x = -(x + 1)
# Hence:
#   ~5   = -(5 + 1)   = -6
#   ~(-5) = -(-5 + 1) = 4

