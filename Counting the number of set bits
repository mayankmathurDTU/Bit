# ðŸ’¡ Concept: Counting the number of set bits (1s) in a numberâ€™s binary representation.

# Example: n = 13 â†’ 1101 â†’ has 3 set bits

# ------------------------------------------
# ðŸ”¹ Approach 1: Bitwise check (Right Shift)
# Check each bit by ANDing with 1, then shift right.
# Time complexity: O(log n)
# ------------------------------------------

# Concept:
# n & 1 â†’ checks if last bit is 1
# n >> 1 â†’ shifts right to check next bit

# Example:
# n = 13 -> 1101
# Step1: 1101 & 0001 â†’ 1 â†’ count=1
# Step2: 0110 & 0001 â†’ 0 â†’ count=1
# Step3: 0011 & 0001 â†’ 1 â†’ count=2
# Step4: 0001 & 0001 â†’ 1 â†’ count=3 âœ…

# C++:
int countSetBits_1(int n) {
    int count = 0;
    while (n > 0) {
        if (n & 1) count++;
        n >>= 1;
    }
    return count;
}

# ------------------------------------------
# ðŸ”¹ Approach 2: Brian Kernighanâ€™s Algorithm
# Keep removing the last set bit until n becomes 0.
# Each operation removes one set bit.
# Time complexity: O(k) where k = number of set bits
# ------------------------------------------

# Concept:
# n = n & (n - 1) removes the last set bit.
# Count how many times we can do that.

# Example:
# n = 13 -> 1101
# n-1 = 12 -> 1100
# n & (n-1) = 1100 â†’ 1 bit removed (count=1)
# 1100 & 1011 = 1000 â†’ 1 bit removed (count=2)
# 1000 & 0111 = 0000 â†’ 1 bit removed (count=3) âœ…

# C++:
int countSetBits_2(int n) {
    int count = 0;
    while (n > 0) {
        n = n & (n - 1);
        count++;
    }
    return count;
}

# ------------------------------------------
# ðŸ”¹ Approach 3: Using Built-in Function (C++)
# Modern compilers provide __builtin_popcount for integers.
# Fastest and simplest.
# ------------------------------------------

# C++:
int countSetBits_3(int n) {
    return __builtin_popcount(n);
}

# Example Outputs:
# n = 13 â†’ 3
# n = 7  â†’ 3
# n = 1023 â†’ 10

# ------------------------------------------
# ðŸ§  Summary:
# Approach 1 â†’ Simple, O(log n)
# Approach 2 â†’ Efficient, O(k)
# Approach 3 â†’ Best, uses CPU instruction
